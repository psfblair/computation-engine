{"name":"Computation-engine","tagline":"A Scala library for evaluating sequences of computations written as Scala strings, on domains of arbitrary facts.","body":"*\"You can build a simple rules engine yourself. All you need is to create a bunch of objects with conditions and actions, store them in a collection, and run through them to evaluate the conditions and execute the actions.\" -- Martin Fowler, [\"Rules Engine\"][rules-engine]*\r\n\r\nAt first blush, the [Computation Engine][computation-engine] project is just what Martin Fowler describes: a way of specifying a sequence of \"rules\" to execute. Unlike rules engines, though, Computation Engine is not a truth-maintenance system and does not support sophisticated techniques like backward chaining. The rules engine that Martin Fowler describes contains rules that are a series of if-then statements, and that can be written in any order. Here the vision is simpler: Put some input in at the front, run through a deterministic series of steps, and get some output at the end. The steps might be rules, but they can be any sort of computation.\r\n\r\nThis description seems no different from that of a regular function. What's so special about Computation Engine\"?\r\n\r\nFirst and most obvious is that computations are specified at runtime, not compile time. Computation Engine is a Scala library, and is intended to be used in Scala applications. However, the computations aren't compiled in to your application; they get evaluated in a sandbox by the Scala Script Engine at runtime. As a result, you can do things like store computations as text strings in a database and read them in when your application starts. You don't have to rebuild and redeploy a service (or your entire system) whenever your business rules change.\r\n\r\nBut don't go thinking that Computation Engine will let business people specify computations themselves, as some rules engines claim to allow. The expression language that Computation Engine understands is Scala, and using this library requires not only knowing how to write Scala code to express computations, but also how to instantiate computations. A user will need to have a fair amount of tech-savvy to use this library. Computation Engine is not only not a Business-Writable DSL, it is not even a Business-Readable DSL.\r\n\r\nComputation Engine has significant implications on how you write your code. The beginning of the chain of computation receives a Scala map of `Symbol -> Any`, and the ultimate result is a similar map. Abandon all type safety ye who enter here!\r\n\r\nThe advantage of removing type constraints is that it allows computations to be specified on any arbitrary subset of the incoming data. For any given computation, you use particular values from the data map with certain types, e.g., the computation may use the value for the key `'maxValue`, which is an integer, while also using that for `'accountId`, which is a string. But the incoming data map can combine values of many different types, and the results of computations can add values of new types to the map, without facing the wrath of the type checker. (This may be what Rich Hickey means when he says \"let data be data.\")\r\n\r\nOf course, once the chain of computations is over and you go back into Scala land, you'll have to return data of types that your application expects. But how you get there is something you can change on the fly without having to modify the rest of your application.\r\n\r\nSince you can't rely on the compiler to check that the right data is being passed in,  you'll have to test the hell out of your computations' clients to make sure they will always obey the contract your computation implicitly specifies. Similarly, you need to test each computation in the chain to make sure its results will always follow the contracts of later computations that depend on that data. Finally, you need to test that you will always be providing results in a form that client code expects. One future direction for Computation Engine is to supply an application that will infer these contracts and automatically specify what tests need to be written. Ideally, ScalaCheck could be used to automate some of these tests.\r\n\r\nPhilosophically speaking, Computation Engine is not really in harmony with object-oriented design. An object-oriented system generally groups different kinds of data with the operations that pertain to that data; business rules are expressed in the form of interactions among groups of objects. As Steve Freeman and Nat Pryce say, \"The behavior of the system is an emergent property of the composition of the objects--the choice of objects and how they are connected.\"[[1][emergent-property]]\r\n\r\nThe result of object-oriented design is a system in which business rules are \"coded in.\" Depending on the system, it may be easier or harder to change coded-in rules: A static, compiled, class-based language makes them difficult to change, while a dynamic, interpreted, object-based language may make it fairly easy to do so. But the rules are not collected together in one place; they emerge from the interaction of the entire system of objects. Tugging on something over here can result in unexpected consequences over there.\r\n\r\nComputation Engine instead envisions a strict separation of operations and data. This means that once the computations are finished, you'll likely be putting the results into objects that are little more than data structures, without much in the way of methods or behaviors. In other words, you'll have an [Anemic Domain Model][anemic-model]. This is by design, and you'll have to put up with being accused of promoting an anti-pattern. Situations in which your business rules are complex and likely to fluctuate a lot are not ideal candidates for object-oriented design: You'll spend a lot of time coming up with careful abstractions to cover all the scenarios you know about, and then something will come along that overturns some fundamental assumption and force you to redesign the whole thing.\r\n\r\nThe approach taken by Computation Engine is not entirely flexible, of course. You can modify your computations as you wish, but your flexibility is still limited by the data you pass in. If your database queries or user input fields don't supply the data you need, then you'll have no alternative but to re-code them to provide that data. The runtime specification of arbitrary database queries or user input fields is beyond the scope of this framework, and may not even be desirable from a data security point of view. But you'll be a lot more likely to succeed at predicting all the possible data that might be relevant to a certain type of computation, than at predicting all the different possible ways in which the computation might need to be carried out.\r\n\r\nComputation Engine is friendlier to functional programming than to OO. Computations are intended to be stateless; the default security configuration for the Scala Script Engine generally restricts the accessible classes to ones that have no side effects. You can get around this restriction by supplying your own security configuration, but it's not recommended. Testing computations is hard enough without having to worry about verifying changes in state.\r\n\r\nBesides tools for testing, the roadmap for Computation Engine envisions providing a library for reading rules from persistent storage, as well as editing tools for authoring, persisting, and publishing rules. Stay tuned for developments.\r\n\r\nIn the meantime, enjoy!\r\n\r\n[rules-engine]:    http://martinfowler.com/bliki/RulesEngine.html\r\n[computation-engine]:    http://github.com/cyrusinnovation/computation-engine\r\n[emergent-property]: http://books.google.com/books?id=QJA3dM8Uix0C&lpg=PT45&ots=zrUiA-fCJo&pg=PT45#v=onepage&q&f=false\r\n[anemic-model]: http://www.martinfowler.com/bliki/AnemicDomainModel.html","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}