Operations: New version
Load computations from computation graph
Read from XML? Later.
Save to db
Edit
Commit

Base node is a Version
    A version has a version number.
    It has a state: Editable / Committed
    It has a date which updates every time it is edited until it is finally committed.

Underneath the version are computations.
    Each has a "changed in version..." which indicates if the computation was edited in this version
        (computation graph will be copied over at the start of each new version)

A Named Computation is something that can be referred to in code. I can ask the db to instantiate a computation of that name for me.
    This could be any type of computation.
    A Named Computation node has:
        1. Package name
        2. Computation name (Class name)
        3. Description

A Simple Computation node is always a Named Computation node. It has:
    1. Computation expression
    2. List of imports. [How is a list represented? Will the db store a list?]
    3. Map of input identifiers
    4. Result key
    5. "Should propagate exceptions" flag
    6. Logger - this is a key into a map of loggers that the code keeps. (Needs to be passed in to the instantiator)
    7. Security configuration - this is a key into a map of security configurations that the code keeps. (Needs to be passed in to the instantiator)

    A Simple Computation is always a leaf node.

An AbortIf node is always a Named Computation node. It has:
    1. Predicate expression
    2. List of imports. [How is a list represented? Will the db store a list?]
    3. Map of input identifiers
    4. "Should propagate exceptions" flag
    5. Logger - this is a key into a map of loggers that the code keeps. (Needs to be passed in to the instantiator)
    6. Security configuration - this is a key into a map of security configurations that the code keeps. (Needs to be passed in to the instantiator)

    An AbortIf Computation always has exactly one child node.

AbortIfHasResults / AbortIfNoResults computations may be named, or not.

    One of these aborting computations always has exactly one child node.

IterativeComputation / MappingComputation computations may be named, or not. They have:
    1. Input mapping
    2. Result key

    One of these iterative/mapping computations always has exactly one child node

A Sequential Computation node may be named, or not.

    One of these always has exactly one child node, pointing to a Sequence Item node which is the beginning of the sequence.

A Sequence Item node is never named. It can only be a child of a Sequential Computation node or another Sequence Item node.

    One of these always has exactly one child node, pointing to the next Sequence Item node.
    If the Sequence Item is at the end of the sequence, then...?

****************************************

I want to create a sequence. I have to name it.
    In the sequence I want first an iterative to surround an abort if no results to surround #1 simple
    Then I want a mapping to surround an abort to surround an iterative to surround #2 simple

Working from the leaves up - I want to surround #1 with an AINR, surround that with an iterative, put that first in sequence
Then I want to surround #2 with an iterative, with a named Abort If, with a mapping, put that second in sequence
Say we wannt to put the sequence in another sequence.
I am making a tree of nodes of different types.

Maybe best way to store these is in a document db?
    Maybe Sequential / Iterative / Mapping / AbortIfNoResults / AbortIfHasResults are "anonymous" if not top-level
        They only point to other nodes.
        Optionally they can have ID info in order for the whole tree to be used elsewhere.
    Top-level nodes have ID, package, etc.
    Simple computations and AbortIfs have ID, package, name, etc.


****************************************
Computation Table - package + computation name + version number is a unique key
1. DB ID
2. Package name
3. Computation name
4. Description
5. Version number

Simple computation table:
1. Computation expression
2. Result key
3. Should propagate exceptions
4. Logger?
5. Security configuration?

    Related tables:
        Imports - foreign key to computation table, plus the import. (Will need new row for every version.)
        Input identifiers - foreign key to computation table, identifier_with_type, input_data_key

AbortIf table:
1. Predicate expression
2. Inner computation - foreign key into computation table
3. Should propagate exceptions
4. Logger?
5. Security configuration?

    Related tables:
        Imports - foreign key to computation table, plus the import. (Will need new row for every version.)
        Input identifiers - foreign key to computation table, identifier_with_type, input_data_key

AbortIfHasResults / AbortIfNoResults
1. Inner computation - foreign key into computation table

Sequential computation

    Related tables:
        Inner computations - foreign key to sequential computation, foreign key to computation table, order

IterativeComputation / MappingComputation
1. Inner computation - foreign key into computation table
2. Result key

****************************************
Simple Computation:
1. Imports - A list. Probably needs a separate table.
2. The computation expression
3. An input identifier mapping - A map of `String -> Symbol` whose keys are of the form `identifer:Type` and values are symbols
4. A result key - A symbol that will be the key for the result of the computation.
6. A "should propagate exceptions" flag - Whether the computation should rethrow an exception when the expression is compiled or applied.
7. A security configuration - An instance of the `SecurityConfiguration` trait indicating what packages
  are safe to load, what classes in those packages are unsafe to load, and where the Java security policy
  file for the current security manager is.
8. A logger - An instance of `com.cyrusinnovation.computation.util.Log`.

SequentialComputation just takes the sequence of inner computations - is order-dependent.
AbortIfNoResults /  AbortIfHasResults just take inner computations.

IterativeComputation / MappingComputation take:
    The inner computation
    an inputMapping
    a result key.

AbortIf takes
the inner computation and:
1. Imports - A list. Probably needs a separate table.
2. The predicate expression.
3. An input identifier mapping - A map of `String -> Symbol` whose keys are of the form `identifer:Type` and values are symbols
4. A security configuration - An instance of the `SecurityConfiguration` trait indicating what packages
  are safe to load, what classes in those packages are unsafe to load, and where the Java security policy
  file for the current security manager is.
5. A logger - An instance of `com.cyrusinnovation.computation.util.Log`.
6. A "should propagate exceptions" flag - Whether the computation should rethrow an exception when the expression is compiled or applied.

No result key.